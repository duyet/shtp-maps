import{S as t,c as e,i as s,f as i,d as n,r as o,P as r,F as a,T as h,a as d,s as c,V as l,b as _,n as u,e as g,g as f,I as C,E as p,M as m,h as y,j as k,k as x,l as P,m as w,L as T,o as v,p as I,q as F,t as L,u as D,v as S,w as M,B as E,G,x as N,y as O,z as R}from"./main-Dtx7NePm.js";class q extends t{constructor(t,e,s){super(),void 0!==s&&void 0===e?this.setFlatCoordinates(s,t):(e=e||0,this.setCenterAndRadius(t,e,s))}clone(){const t=new q(this.flatCoordinates.slice(),void 0,this.layout);return t.applyProperties(this),t}closestPointXY(t,e,s,i){const n=this.flatCoordinates,o=t-n[0],r=e-n[1],a=o*o+r*r;if(a<i){if(0===a)for(let t=0;t<this.stride;++t)s[t]=n[t];else{const t=this.getRadius()/Math.sqrt(a);s[0]=n[0]+t*o,s[1]=n[1]+t*r;for(let e=2;e<this.stride;++e)s[e]=n[e]}return s.length=this.stride,a}return i}containsXY(t,e){const s=this.flatCoordinates,i=t-s[0],n=e-s[1];return i*i+n*n<=this.getRadiusSquared_()}getCenter(){return this.flatCoordinates.slice(0,this.stride)}computeExtent(t){const s=this.flatCoordinates,i=s[this.stride]-s[0];return e(s[0]-i,s[1]-i,s[0]+i,s[1]+i,t)}getRadius(){return Math.sqrt(this.getRadiusSquared_())}getRadiusSquared_(){const t=this.flatCoordinates[this.stride]-this.flatCoordinates[0],e=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return t*t+e*e}getType(){return"Circle"}intersectsExtent(t){const e=this.getExtent();if(s(t,e)){const e=this.getCenter();return t[0]<=e[0]&&t[2]>=e[0]||(t[1]<=e[1]&&t[3]>=e[1]||i(t,this.intersectsCoordinate.bind(this)))}return!1}setCenter(t){const e=this.stride,s=this.flatCoordinates[e]-this.flatCoordinates[0],i=t.slice();i[e]=i[0]+s;for(let n=1;n<e;++n)i[e+n]=t[n];this.setFlatCoordinates(this.layout,i),this.changed()}setCenterAndRadius(t,e,s){this.setLayout(s,t,0),this.flatCoordinates||(this.flatCoordinates=[]);const i=this.flatCoordinates;let o=n(i,0,t,this.stride);i[o++]=i[0]+e;for(let n=1,r=this.stride;n<r;++n)i[o++]=i[n];i.length=o,this.changed()}getCoordinates(){return null}setCoordinates(t,e){}setRadius(t){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+t,this.changed()}rotate(t,e){const s=this.getCenter(),i=this.getStride();this.setCenter(o(s,0,s.length,i,t,e,s)),this.changed()}}q.prototype.transform;const V="drawstart",b="drawend",H="drawabort";class U extends E{constructor(t,e){super(t),this.feature=e}}function A(t,e){return N(t[0],t[1],e[0],e[1])}function j(t,e){const s=t.length;return e<0?t[e+s]:e>=s?t[e-s]:t[e]}function X(t,e,s){let i,n;e<s?(i=e,n=s):(i=s,n=e);const o=Math.ceil(i),r=Math.floor(n);if(o>r){return A(J(t,i),J(t,n))}let a=0;if(i<o){a+=A(J(t,i),j(t,o))}if(r<n){a+=A(j(t,r),J(t,n))}for(let h=o;h<r-1;++h){a+=A(j(t,h),j(t,h+1))}return a}function Y(t,e,s){if(e instanceof T)W(t,e.getCoordinates(),!1,s);else{if(e instanceof F){const i=e.getCoordinates();for(let e=0,n=i.length;e<n;++e)W(t,i[e],!1,s);return}if(e instanceof D){const i=e.getCoordinates();for(let e=0,n=i.length;e<n;++e)W(t,i[e],!0,s);return}if(e instanceof L){const i=e.getCoordinates();for(let e=0,n=i.length;e<n;++e){const n=i[e];for(let e=0,i=n.length;e<i;++e)W(t,n[e],!0,s)}return}if(e instanceof G){const i=e.getGeometries();for(let e=0;e<i.length;++e)Y(t,i[e],s);return}}}const B={index:-1,endIndex:NaN};function W(t,e,s,i){const n=t[0],o=t[1];for(let r=0,a=e.length-1;r<a;++r){const t=K(n,o,e[r],e[r+1]);if(0===t.squaredDistance){const n=r+t.along;return void i.push({coordinates:e,ring:s,startIndex:n,endIndex:n})}}}const z={along:0,squaredDistance:0};function K(t,e,s,i){const n=s[0],o=s[1],r=i[0]-n,a=i[1]-o;let h=0,d=n,c=o;return 0===r&&0===a||(h=R(((t-n)*r+(e-o)*a)/(r*r+a*a),0,1),d+=r*h,c+=a*h),z.along=h,z.squaredDistance=O(N(t,e,d,c),10),z}function J(t,e){const s=t.length;let i=Math.floor(e);const n=e-i;i>=s?i-=s:i<0&&(i+=s);let o=i+1;o>=s&&(o-=s);const r=t[i],a=r[0],h=r[1],d=t[o];return[a+(d[0]-a)*n,h+(d[1]-h)*n]}class Q extends r{constructor(t){const e=t;e.stopDown||(e.stopDown=a),super(e),this.on,this.once,this.un,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=t.source?t.source:null,this.features_=t.features?t.features:null,this.snapTolerance_=t.snapTolerance?t.snapTolerance:12,this.type_=t.type,this.mode_=function(t){switch(t){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+t)}}(this.type_),this.stopClick_=!!t.stopClick,this.minPoints_=t.minPoints?t.minPoints:"Polygon"===this.mode_?3:2,this.maxPoints_="Circle"===this.mode_?2:t.maxPoints?t.maxPoints:1/0,this.finishCondition_=t.finishCondition?t.finishCondition:h,this.geometryLayout_=t.geometryLayout?t.geometryLayout:"XY";let s=t.geometryFunction;if(!s){const t=this.mode_;if("Circle"===t)s=function(t,e,s){const i=e||new q([NaN,NaN]),n=d(t[0]),o=c(n,d(t[t.length-1]));return i.setCenterAndRadius(n,Math.sqrt(o),this.geometryLayout_),i};else{let e;"Point"===t?e=w:"LineString"===t?e=T:"Polygon"===t&&(e=D),s=function(s,i,n){return i?"Polygon"===t?s[0].length?i.setCoordinates([s[0].concat([s[0][0]])],this.geometryLayout_):i.setCoordinates([],this.geometryLayout_):i.setCoordinates(s,this.geometryLayout_):i=new e(s,this.geometryLayout_),i}}}this.geometryFunction_=s,this.dragVertexDelay_=void 0!==t.dragVertexDelay?t.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=t.clickTolerance?t.clickTolerance*t.clickTolerance:36,this.overlay_=new l({source:new _({useSpatialIndex:!1,wrapX:!!t.wrapX&&t.wrapX}),style:t.style?t.style:Z(),updateWhileInteracting:!0}),this.geometryName_=t.geometryName,this.condition_=t.condition?t.condition:u,this.freehandCondition_,t.freehand?this.freehandCondition_=g:this.freehandCondition_=t.freehandCondition?t.freehandCondition:f,this.traceCondition_,this.setTrace(t.trace||!1),this.traceState_={active:!1},this.traceSource_=t.traceSource||t.source||null,this.addChangeListener(C.ACTIVE,this.updateState_)}setTrace(t){let e;e=t?!0===t?g:t:S,this.traceCondition_=e}setMap(t){super.setMap(t),this.updateState_()}getOverlay(){return this.overlay_}handleEvent(t){t.originalEvent.type===p.CONTEXTMENU&&t.originalEvent.preventDefault(),this.freehand_="Point"!==this.mode_&&this.freehandCondition_(t);let e=t.type===m.POINTERMOVE,s=!0;if(!this.freehand_&&this.lastDragTime_&&t.type===m.POINTERDRAG){Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=t.pixel,this.shouldHandle_=!this.freehand_,e=!0):this.lastDragTime_=void 0,this.shouldHandle_&&void 0!==this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)}return this.freehand_&&t.type===m.POINTERDRAG&&null!==this.sketchFeature_?(this.addToDrawing_(t.coordinate),s=!1):this.freehand_&&t.type===m.POINTERDOWN?s=!1:e&&this.getPointerCount()<2?(s=t.type===m.POINTERMOVE,s&&this.freehand_?(this.handlePointerMove_(t),this.shouldHandle_&&t.originalEvent.preventDefault()):("mouse"===t.originalEvent.pointerType||t.type===m.POINTERDRAG&&void 0===this.downTimeout_)&&this.handlePointerMove_(t)):t.type===m.DBLCLICK&&(s=!1),super.handleEvent(t)&&s}handleDownEvent(t){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=t.pixel,this.finishCoordinate_||this.startDrawing_(t.coordinate),!0):this.condition_(t)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(()=>{this.handlePointerMove_(new y(m.POINTERMOVE,t.map,t.originalEvent,!1,t.frameState))},this.dragVertexDelay_),this.downPx_=t.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(t){if(!this.traceSource_||!this.traceCondition_(t))return;if(this.traceState_.active)return void this.deactivateTrace_();const e=this.getMap(),s=e.getCoordinateFromPixel([t.pixel[0]-this.snapTolerance_,t.pixel[1]+this.snapTolerance_]),i=e.getCoordinateFromPixel([t.pixel[0]+this.snapTolerance_,t.pixel[1]-this.snapTolerance_]),n=k([s,i]),o=this.traceSource_.getFeaturesInExtent(n);if(0===o.length)return;const r=function(t,e){const s=[];for(let i=0;i<e.length;++i)Y(t,e[i].getGeometry(),s);return s}(t.coordinate,o);r.length&&(this.traceState_={active:!0,startPx:t.pixel.slice(),targets:r,targetIndex:-1})}addOrRemoveTracedCoordinates_(t,e){const s=t.startIndex<=t.endIndex;s===t.startIndex<=e?s&&e>t.endIndex||!s&&e<t.endIndex?this.addTracedCoordinates_(t,t.endIndex,e):(s&&e<t.endIndex||!s&&e>t.endIndex)&&this.removeTracedCoordinates_(e,t.endIndex):(this.removeTracedCoordinates_(t.startIndex,t.endIndex),this.addTracedCoordinates_(t,t.startIndex,e))}removeTracedCoordinates_(t,e){if(t===e)return;let s=0;if(t<e){const i=Math.ceil(t);let n=Math.floor(e);n===e&&(n-=1),s=n-i+1}else{const i=Math.floor(t);let n=Math.ceil(e);n===e&&(n+=1),s=i-n+1}s>0&&this.removeLastPoints_(s)}addTracedCoordinates_(t,e,s){if(e===s)return;const i=[];if(e<s){const n=Math.ceil(e);let o=Math.floor(s);o===s&&(o-=1);for(let e=n;e<=o;++e)i.push(j(t.coordinates,e))}else{const n=Math.floor(e);let o=Math.ceil(s);o===s&&(o+=1);for(let e=n;e>=o;--e)i.push(j(t.coordinates,e))}i.length&&this.appendCoordinates(i)}updateTrace_(t){const e=this.traceState_;if(!e.active)return;if(-1===e.targetIndex&&x(e.startPx,t.pixel)<this.snapTolerance_)return;const s=function(t,e,s,i){const n=t[0],o=t[1];let r=1/0,a=-1,h=NaN;for(let l=0;l<e.targets.length;++l){const t=e.targets[l],s=t.coordinates;let i,d=1/0;for(let e=0;e<s.length-1;++e){const t=K(n,o,s[e],s[e+1]);t.squaredDistance<d&&(d=t.squaredDistance,i=e+t.along)}d<r&&(r=d,t.ring&&e.targetIndex===l&&(t.endIndex>t.startIndex?i<t.startIndex&&(i+=s.length):t.endIndex<t.startIndex&&i>t.startIndex&&(i-=s.length)),h=i,a=l)}const d=e.targets[a];let c=d.ring;if(e.targetIndex===a&&c){const t=J(d.coordinates,h),n=s.getPixelFromCoordinate(t);x(n,e.startPx)>i&&(c=!1)}if(c){const t=d.coordinates,e=t.length,s=d.startIndex,i=h;if(s<i){const n=X(t,s,i);X(t,s,i-e)<n&&(h-=e)}else{const n=X(t,s,i);X(t,s,i+e)<n&&(h+=e)}}return B.index=a,B.endIndex=h,B}(t.coordinate,e,this.getMap(),this.snapTolerance_);if(e.targetIndex!==s.index){if(-1!==e.targetIndex){const t=e.targets[e.targetIndex];this.removeTracedCoordinates_(t.startIndex,t.endIndex)}const t=e.targets[s.index];this.addTracedCoordinates_(t,t.startIndex,s.endIndex)}else{const t=e.targets[e.targetIndex];this.addOrRemoveTracedCoordinates_(t,s.endIndex)}e.targetIndex=s.index;const i=e.targets[e.targetIndex];i.endIndex=s.endIndex;const n=J(i.coordinates,i.endIndex),o=this.getMap().getPixelFromCoordinate(n);t.coordinate=n,t.pixel=[Math.round(o[0]),Math.round(o[1])]}handleUpEvent(t){let e=!0;if(0===this.getPointerCount()){this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(t);const s=this.traceState_.active;if(this.toggleTraceState_(t),this.shouldHandle_){const i=!this.finishCoordinate_;i&&this.startDrawing_(t.coordinate),!i&&this.freehand_?this.finishDrawing():this.freehand_||i&&"Point"!==this.mode_||(this.atFinish_(t.pixel,s)?this.finishCondition_(t)&&this.finishDrawing():this.addToDrawing_(t.coordinate)),e=!1}else this.freehand_&&this.abortDrawing()}return!e&&this.stopClick_&&t.preventDefault(),e}handlePointerMove_(t){if(this.pointerType_=t.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const e=this.downPx_,s=t.pixel,i=e[0]-s[0],n=e[1]-s[1],o=i*i+n*n;if(this.shouldHandle_=this.freehand_?o>this.squaredClickTolerance_:o<=this.squaredClickTolerance_,!this.shouldHandle_)return}this.finishCoordinate_?(this.updateTrace_(t),this.modifyDrawing_(t.coordinate)):this.createOrUpdateSketchPoint_(t.coordinate.slice())}atFinish_(t,e){let s=!1;if(this.sketchFeature_){let i=!1,n=[this.finishCoordinate_];const o=this.mode_;if("Point"===o)s=!0;else if("Circle"===o)s=2===this.sketchCoords_.length;else if("LineString"===o)i=!e&&this.sketchCoords_.length>this.minPoints_;else if("Polygon"===o){const t=this.sketchCoords_;i=t[0].length>this.minPoints_,n=[t[0][0],t[0][t[0].length-2]],n=e?[t[0][0]]:[t[0][0],t[0][t[0].length-2]]}if(i){const e=this.getMap();for(let i=0,o=n.length;i<o;i++){const o=n[i],r=e.getPixelFromCoordinate(o),a=t[0]-r[0],h=t[1]-r[1],d=this.freehand_?1:this.snapTolerance_;if(s=Math.sqrt(a*a+h*h)<=d,s){this.finishCoordinate_=o;break}}}}return s}createOrUpdateSketchPoint_(t){if(this.sketchPoint_){this.sketchPoint_.getGeometry().setCoordinates(t)}else this.sketchPoint_=new P(new w(t)),this.updateSketchFeatures_()}createOrUpdateCustomSketchLine_(t){this.sketchLine_||(this.sketchLine_=new P);const e=t.getLinearRing(0);let s=this.sketchLine_.getGeometry();s?(s.setFlatCoordinates(e.getLayout(),e.getFlatCoordinates()),s.changed()):(s=new T(e.getFlatCoordinates(),e.getLayout()),this.sketchLine_.setGeometry(s))}startDrawing_(t){const e=this.getMap().getView().getProjection(),s=v(this.geometryLayout_);for(;t.length<s;)t.push(0);this.finishCoordinate_=t,"Point"===this.mode_?this.sketchCoords_=t.slice():"Polygon"===this.mode_?(this.sketchCoords_=[[t.slice(),t.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[t.slice(),t.slice()],this.sketchLineCoords_&&(this.sketchLine_=new P(new T(this.sketchLineCoords_)));const i=this.geometryFunction_(this.sketchCoords_,void 0,e);this.sketchFeature_=new P,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(i),this.updateSketchFeatures_(),this.dispatchEvent(new U(V,this.sketchFeature_))}modifyDrawing_(t){const e=this.getMap(),s=this.sketchFeature_.getGeometry(),i=e.getView().getProjection(),n=v(this.geometryLayout_);let o,r;for(;t.length<n;)t.push(0);if("Point"===this.mode_?r=this.sketchCoords_:"Polygon"===this.mode_?(o=this.sketchCoords_[0],r=o[o.length-1],this.atFinish_(e.getPixelFromCoordinate(t))&&(t=this.finishCoordinate_.slice())):(o=this.sketchCoords_,r=o[o.length-1]),r[0]=t[0],r[1]=t[1],this.geometryFunction_(this.sketchCoords_,s,i),this.sketchPoint_){this.sketchPoint_.getGeometry().setCoordinates(t)}if("Polygon"===s.getType()&&"Polygon"!==this.mode_)this.createOrUpdateCustomSketchLine_(s);else if(this.sketchLineCoords_){this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_)}this.updateSketchFeatures_()}addToDrawing_(t){const e=this.sketchFeature_.getGeometry(),s=this.getMap().getView().getProjection();let i,n;const o=this.mode_;"LineString"===o||"Circle"===o?(this.finishCoordinate_=t.slice(),n=this.sketchCoords_,n.length>=this.maxPoints_&&(this.freehand_?n.pop():i=!0),n.push(t.slice()),this.geometryFunction_(n,e,s)):"Polygon"===o&&(n=this.sketchCoords_[0],n.length>=this.maxPoints_&&(this.freehand_?n.pop():i=!0),n.push(t.slice()),i&&(this.finishCoordinate_=n[0]),this.geometryFunction_(this.sketchCoords_,e,s)),this.createOrUpdateSketchPoint_(t.slice()),this.updateSketchFeatures_(),i&&this.finishDrawing()}removeLastPoints_(t){if(!this.sketchFeature_)return;const e=this.sketchFeature_.getGeometry(),s=this.getMap().getView().getProjection(),i=this.mode_;for(let n=0;n<t;++n){let t;if("LineString"===i||"Circle"===i){if(t=this.sketchCoords_,t.splice(-2,1),t.length>=2){this.finishCoordinate_=t[t.length-2].slice();const e=this.finishCoordinate_.slice();t[t.length-1]=e,this.createOrUpdateSketchPoint_(e)}this.geometryFunction_(t,e,s),"Polygon"===e.getType()&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(e)}else if("Polygon"===i){t=this.sketchCoords_[0],t.splice(-2,1);const i=this.sketchLine_.getGeometry();if(t.length>=2){const e=t[t.length-2].slice();t[t.length-1]=e,this.createOrUpdateSketchPoint_(e)}i.setCoordinates(t),this.geometryFunction_(this.sketchCoords_,e,s)}if(1===t.length){this.abortDrawing();break}}this.updateSketchFeatures_()}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const t=this.abortDrawing_();if(!t)return;let e=this.sketchCoords_;const s=t.getGeometry(),i=this.getMap().getView().getProjection();"LineString"===this.mode_?(e.pop(),this.geometryFunction_(e,s,i)):"Polygon"===this.mode_&&(e[0].pop(),this.geometryFunction_(e,s,i),e=s.getCoordinates()),"MultiPoint"===this.type_?t.setGeometry(new I([e])):"MultiLineString"===this.type_?t.setGeometry(new F([e])):"MultiPolygon"===this.type_&&t.setGeometry(new L([e])),this.dispatchEvent(new U(b,t)),this.features_&&this.features_.push(t),this.source_&&this.source_.addFeature(t)}abortDrawing_(){this.finishCoordinate_=null;const t=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),t}abortDrawing(){const t=this.abortDrawing_();t&&this.dispatchEvent(new U(H,t))}appendCoordinates(t){const e=this.mode_,s=!this.sketchFeature_;let i;if(s&&this.startDrawing_(t[0]),"LineString"===e||"Circle"===e)i=this.sketchCoords_;else{if("Polygon"!==e)return;i=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[]}s&&i.shift(),i.pop();for(let o=0;o<t.length;o++)this.addToDrawing_(t[o]);const n=t[t.length-1];this.addToDrawing_(n),this.modifyDrawing_(n)}extend(t){const e=t.getGeometry();this.sketchFeature_=t,this.sketchCoords_=e.getCoordinates();const s=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=s.slice(),this.sketchCoords_.push(s.slice()),this.sketchPoint_=new P(new w(s)),this.updateSketchFeatures_(),this.dispatchEvent(new U(V,this.sketchFeature_))}updateSketchFeatures_(){const t=[];this.sketchFeature_&&t.push(this.sketchFeature_),this.sketchLine_&&t.push(this.sketchLine_),this.sketchPoint_&&t.push(this.sketchPoint_);const e=this.overlay_.getSource();e.clear(!0),e.addFeatures(t)}updateState_(){const t=this.getMap(),e=this.getActive();t&&e||this.abortDrawing(),this.overlay_.setMap(e?t:null)}}function Z(){const t=M();return function(e,s){return t[e.getGeometry().getType()]}}export{U as DrawEvent,Q as default};
//# sourceMappingURL=Draw-V_kax7x4.js.map

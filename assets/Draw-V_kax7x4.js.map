{"version":3,"file":"Draw-V_kax7x4.js","sources":["../../node_modules/ol/geom/Circle.js","../../node_modules/ol/interaction/Draw.js"],"sourcesContent":["/**\n * @module ol/geom/Circle\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {rotate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nclass Circle extends SimpleGeometry {\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius in units of the projection.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(center, radius, layout) {\n    super();\n    if (layout !== undefined && radius === undefined) {\n      this.setFlatCoordinates(layout, center);\n    } else {\n      radius = radius ? radius : 0;\n      this.setCenterAndRadius(center, radius, layout);\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   */\n  clone() {\n    const circle = new Circle(\n      this.flatCoordinates.slice(),\n      undefined,\n      this.layout\n    );\n    circle.applyProperties(this);\n    return circle;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    const squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (let i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (let i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  }\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius,\n      flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius,\n      flatCoordinates[1] + radius,\n      extent\n    );\n  }\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  }\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  getRadiusSquared_() {\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Circle';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      const center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  }\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  setCenter(center) {\n    const stride = this.stride;\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    const flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (let i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  }\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCenterAndRadius(center, radius, layout) {\n    this.setLayout(layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    const flatCoordinates = this.flatCoordinates;\n    let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n\n  getCoordinates() {\n    return null;\n  }\n\n  setCoordinates(coordinates, layout) {}\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(\n      rotate(center, 0, center.length, stride, angle, anchor, center)\n    );\n    this.changed();\n  }\n}\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n","/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {\n  always,\n  never,\n  noModifierKeys,\n  shiftKeyOnly,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../extent.js';\nimport {clamp, squaredDistance, toFixed} from '../math.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {\n  distance,\n  squaredDistance as squaredCoordinateDistance,\n} from '../coordinate.js';\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.\n * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.\n * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with\n * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.\n * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`\n * geometry that corresponds to the polygon between the already drawn points and the current cursor position\n * (note that this polygon has only two points if only one point is drawn).\n * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose\n * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean|import(\"../events/condition.js\").Condition} [trace=false] Trace a portion of another geometry.\n * Ignored when in freehand mode.\n * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is\n * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with\n * either a `traceSource` or a `source`.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * @typedef {Object} TraceState\n * @property {boolean} active Tracing active.\n * @property {import(\"../pixel.js\").Pixel} [startPx] The initially clicked pixel location.\n * @property {Array<TraceTarget>} [targets] Targets available for tracing.\n * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates\n * that no trace target is active.\n */\n\n/**\n * @typedef {Object} TraceTarget\n * @property {Array<import(\"../coordinate.js\").Coordinate>} coordinates Target coordinates.\n * @property {boolean} ring The target coordinates are a linear ring.\n * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an\n * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).\n * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n */\n\n/**\n * @enum {string}\n */\nconst DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend',\n  /**\n   * Triggered upon feature draw abortion\n   * @event DrawEvent#drawabort\n   * @api\n   */\n  DRAWABORT: 'drawabort',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nexport class DrawEvent extends Event {\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n  constructor(type, feature) {\n    super(type);\n\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n    this.feature = feature;\n  }\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {Array<Feature>} features The candidate features.\n * @return {Array<TraceTarget>} The trace targets.\n */\nfunction getTraceTargets(coordinate, features) {\n  /**\n   * @type {Array<TraceTarget>}\n   */\n  const targets = [];\n\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    const geometry = feature.getGeometry();\n    appendGeometryTraceTargets(coordinate, geometry, targets);\n  }\n\n  return targets;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} a One coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b Another coordinate.\n * @return {number} The squared distance between the two coordinates.\n */\nfunction getSquaredDistance(a, b) {\n  return squaredDistance(a[0], a[1], b[0], b[1]);\n}\n\n/**\n * @param {LineCoordType} coordinates The ring coordinates.\n * @param {number} index The index.  May be wrapped.\n * @return {import(\"../coordinate.js\").Coordinate} The coordinate.\n */\nfunction getCoordinate(coordinates, index) {\n  const count = coordinates.length;\n  if (index < 0) {\n    return coordinates[index + count];\n  }\n  if (index >= count) {\n    return coordinates[index - count];\n  }\n  return coordinates[index];\n}\n\n/**\n * Get the cumulative squared distance along a ring path.  The end index index may be \"wrapped\" and it may\n * be less than the start index to indicate the direction of travel.  The start and end index may have\n * a fractional part to indicate a point between two coordinates.\n * @param {LineCoordType} coordinates Ring coordinates.\n * @param {number} startIndex The start index.\n * @param {number} endIndex The end index.\n * @return {number} The cumulative squared distance along the ring path.\n */\nfunction getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {\n  let lowIndex, highIndex;\n  if (startIndex < endIndex) {\n    lowIndex = startIndex;\n    highIndex = endIndex;\n  } else {\n    lowIndex = endIndex;\n    highIndex = startIndex;\n  }\n  const lowWholeIndex = Math.ceil(lowIndex);\n  const highWholeIndex = Math.floor(highIndex);\n\n  if (lowWholeIndex > highWholeIndex) {\n    // both start and end are on the same segment\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    return getSquaredDistance(start, end);\n  }\n\n  let sd = 0;\n\n  if (lowIndex < lowWholeIndex) {\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = getCoordinate(coordinates, lowWholeIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  if (highWholeIndex < highIndex) {\n    const start = getCoordinate(coordinates, highWholeIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {\n    const start = getCoordinate(coordinates, i);\n    const end = getCoordinate(coordinates, i + 1);\n    sd += getSquaredDistance(start, end);\n  }\n\n  return sd;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {import(\"../geom/Geometry.js\").default} geometry The candidate geometry.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendGeometryTraceTargets(coordinate, geometry, targets) {\n  if (geometry instanceof LineString) {\n    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);\n    return;\n  }\n  if (geometry instanceof MultiLineString) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], false, targets);\n    }\n    return;\n  }\n  if (geometry instanceof Polygon) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], true, targets);\n    }\n    return;\n  }\n  if (geometry instanceof MultiPolygon) {\n    const polys = geometry.getCoordinates();\n    for (let i = 0, ii = polys.length; i < ii; ++i) {\n      const coordinates = polys[i];\n      for (let j = 0, jj = coordinates.length; j < jj; ++j) {\n        appendTraceTarget(coordinate, coordinates[j], true, targets);\n      }\n    }\n    return;\n  }\n  if (geometry instanceof GeometryCollection) {\n    const geometries = geometry.getGeometries();\n    for (let i = 0; i < geometries.length; ++i) {\n      appendGeometryTraceTargets(coordinate, geometries[i], targets);\n    }\n    return;\n  }\n  // other types cannot be traced\n}\n\n/**\n * @typedef {Object} TraceTargetUpdateInfo\n * @property {number} index The new target index.\n * @property {number} endIndex The new segment end index.\n */\n\n/**\n * @type {TraceTargetUpdateInfo}\n */\nconst sharedUpdateInfo = {index: -1, endIndex: NaN};\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {TraceState} traceState The trace state.\n * @param {import(\"../Map.js\").default} map The map.\n * @param {number} snapTolerance The snap tolerance.\n * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned\n * object is reused between calls and must not be modified by the caller.\n */\nfunction getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n\n  let closestTargetDistance = Infinity;\n\n  let newTargetIndex = -1;\n  let newEndIndex = NaN;\n\n  for (\n    let targetIndex = 0;\n    targetIndex < traceState.targets.length;\n    ++targetIndex\n  ) {\n    const target = traceState.targets[targetIndex];\n    const coordinates = target.coordinates;\n\n    let minSegmentDistance = Infinity;\n    let endIndex;\n    for (\n      let coordinateIndex = 0;\n      coordinateIndex < coordinates.length - 1;\n      ++coordinateIndex\n    ) {\n      const start = coordinates[coordinateIndex];\n      const end = coordinates[coordinateIndex + 1];\n      const rel = getPointSegmentRelationship(x, y, start, end);\n      if (rel.squaredDistance < minSegmentDistance) {\n        minSegmentDistance = rel.squaredDistance;\n        endIndex = coordinateIndex + rel.along;\n      }\n    }\n\n    if (minSegmentDistance < closestTargetDistance) {\n      closestTargetDistance = minSegmentDistance;\n      if (target.ring && traceState.targetIndex === targetIndex) {\n        // same target, maintain the same trace direction\n        if (target.endIndex > target.startIndex) {\n          // forward trace\n          if (endIndex < target.startIndex) {\n            endIndex += coordinates.length;\n          }\n        } else if (target.endIndex < target.startIndex) {\n          // reverse trace\n          if (endIndex > target.startIndex) {\n            endIndex -= coordinates.length;\n          }\n        }\n      }\n      newEndIndex = endIndex;\n      newTargetIndex = targetIndex;\n    }\n  }\n\n  const newTarget = traceState.targets[newTargetIndex];\n  let considerBothDirections = newTarget.ring;\n  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {\n    // only consider switching trace direction if close to the start\n    const newCoordinate = interpolateCoordinate(\n      newTarget.coordinates,\n      newEndIndex\n    );\n    const pixel = map.getPixelFromCoordinate(newCoordinate);\n    if (distance(pixel, traceState.startPx) > snapTolerance) {\n      considerBothDirections = false;\n    }\n  }\n\n  if (considerBothDirections) {\n    const coordinates = newTarget.coordinates;\n    const count = coordinates.length;\n    const startIndex = newTarget.startIndex;\n    const endIndex = newEndIndex;\n    if (startIndex < endIndex) {\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex\n      );\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex - count\n      );\n      if (reverseDistance < forwardDistance) {\n        newEndIndex -= count;\n      }\n    } else {\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex\n      );\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex + count\n      );\n      if (forwardDistance < reverseDistance) {\n        newEndIndex += count;\n      }\n    }\n  }\n\n  sharedUpdateInfo.index = newTargetIndex;\n  sharedUpdateInfo.endIndex = newEndIndex;\n  return sharedUpdateInfo;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The clicked coordinate.\n * @param {Array<import(\"../coordinate.js\").Coordinate>} coordinates The geometry component coordinates.\n * @param {boolean} ring The coordinates represent a linear ring.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendTraceTarget(coordinate, coordinates, ring, targets) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    const start = coordinates[i];\n    const end = coordinates[i + 1];\n    const rel = getPointSegmentRelationship(x, y, start, end);\n    if (rel.squaredDistance === 0) {\n      const index = i + rel.along;\n      targets.push({\n        coordinates: coordinates,\n        ring: ring,\n        startIndex: index,\n        endIndex: index,\n      });\n      return;\n    }\n  }\n}\n\n/**\n * @typedef {Object} PointSegmentRelationship\n * @property {number} along The closest point expressed as a fraction along the segment length.\n * @property {number} squaredDistance The squared distance of the point to the segment.\n */\n\n/**\n * @type {PointSegmentRelationship}\n */\nconst sharedRel = {along: 0, squaredDistance: 0};\n\n/**\n * @param {number} x The point x.\n * @param {number} y The point y.\n * @param {import(\"../coordinate.js\").Coordinate} start The segment start.\n * @param {import(\"../coordinate.js\").Coordinate} end The segment end.\n * @return {PointSegmentRelationship} The point segment relationship.  The returned object is\n * shared between calls and must not be modified by the caller.\n */\nfunction getPointSegmentRelationship(x, y, start, end) {\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  let along = 0;\n  let px = x1;\n  let py = y1;\n  if (dx !== 0 || dy !== 0) {\n    along = clamp(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);\n    px += dx * along;\n    py += dy * along;\n  }\n\n  sharedRel.along = along;\n  sharedRel.squaredDistance = toFixed(squaredDistance(x, y, px, py), 10);\n  return sharedRel;\n}\n\n/**\n * @param {LineCoordType} coordinates The coordinates.\n * @param {number} index The index.  May be fractional and may wrap.\n * @return {import(\"../coordinate.js\").Coordinate} The interpolated coordinate.\n */\nfunction interpolateCoordinate(coordinates, index) {\n  const count = coordinates.length;\n\n  let startIndex = Math.floor(index);\n  const along = index - startIndex;\n  if (startIndex >= count) {\n    startIndex -= count;\n  } else if (startIndex < 0) {\n    startIndex += count;\n  }\n\n  let endIndex = startIndex + 1;\n  if (endIndex >= count) {\n    endIndex -= count;\n  }\n\n  const start = coordinates[startIndex];\n  const x0 = start[0];\n  const y0 = start[1];\n  const end = coordinates[endIndex];\n  const dx = end[0] - x0;\n  const dy = end[1] - y0;\n\n  return [x0 + dx * along, y0 + dy * along];\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nclass Draw extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DrawOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.shouldHandle_ = false;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.downPx_ = null;\n\n    /**\n     * @type {ReturnType<typeof setTimeout>}\n     * @private\n     */\n    this.downTimeout_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.lastDragTime_;\n\n    /**\n     * Pointer type of the last pointermove event\n     * @type {string}\n     * @private\n     */\n    this.pointerType_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.freehand_ = false;\n\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n\n    /**\n     * Geometry type.\n     * @type {import(\"../geom/Geometry.js\").Type}\n     * @private\n     */\n    this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (\n      options.type\n    );\n\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n    this.mode_ = getMode(this.type_);\n\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    this.stopClick_ = !!options.stopClick;\n\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    this.minPoints_ = options.minPoints\n      ? options.minPoints\n      : this.mode_ === 'Polygon'\n      ? 3\n      : 2;\n\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    this.maxPoints_ =\n      this.mode_ === 'Circle'\n        ? 2\n        : options.maxPoints\n        ? options.maxPoints\n        : Infinity;\n\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.finishCondition_ = options.finishCondition\n      ? options.finishCondition\n      : TRUE;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     */\n    this.geometryLayout_ = options.geometryLayout\n      ? options.geometryLayout\n      : 'XY';\n\n    let geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      const mode = this.mode_;\n      if (mode === 'Circle') {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          const circle = geometry\n            ? /** @type {Circle} */ (geometry)\n            : new Circle([NaN, NaN]);\n          const center = fromUserCoordinate(coordinates[0], projection);\n          const squaredLength = squaredCoordinateDistance(\n            center,\n            fromUserCoordinate(coordinates[coordinates.length - 1], projection)\n          );\n          circle.setCenterAndRadius(\n            center,\n            Math.sqrt(squaredLength),\n            this.geometryLayout_\n          );\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circle.transform(projection, userProjection);\n          }\n          return circle;\n        };\n      } else {\n        let Constructor;\n        if (mode === 'Point') {\n          Constructor = Point;\n        } else if (mode === 'LineString') {\n          Constructor = LineString;\n        } else if (mode === 'Polygon') {\n          Constructor = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          if (geometry) {\n            if (mode === 'Polygon') {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates(\n                  [coordinates[0].concat([coordinates[0][0]])],\n                  this.geometryLayout_\n                );\n              } else {\n                geometry.setCoordinates([], this.geometryLayout_);\n              }\n            } else {\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\n            }\n          } else {\n            geometry = new Constructor(coordinates, this.geometryLayout_);\n          }\n          return geometry;\n        };\n      }\n    }\n\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n    this.geometryFunction_ = geometryFunction;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dragVertexDelay_ =\n      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.finishCoordinate_ = null;\n\n    /**\n     * Sketch feature.\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n     * @private\n     */\n    this.sketchFeature_ = null;\n\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.sketchPoint_ = null;\n\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n    this.sketchCoords_ = null;\n\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n    this.sketchLine_ = null;\n\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n    this.sketchLineCoords_ = null;\n\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    this.squaredClickTolerance_ = options.clickTolerance\n      ? options.clickTolerance * options.clickTolerance\n      : 36;\n\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.freehandCondition_;\n    if (options.freehand) {\n      this.freehandCondition_ = always;\n    } else {\n      this.freehandCondition_ = options.freehandCondition\n        ? options.freehandCondition\n        : shiftKeyOnly;\n    }\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.traceCondition_;\n    this.setTrace(options.trace || false);\n\n    /**\n     * @type {TraceState}\n     * @private\n     */\n    this.traceState_ = {active: false};\n\n    /**\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.traceSource_ = options.traceSource || options.source || null;\n\n    this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_);\n  }\n\n  /**\n   * Toggle tracing mode or set a tracing condition.\n   *\n   * @param {boolean|import(\"../events/condition.js\").Condition} trace A boolean to toggle tracing mode or an event\n   *     condition that will be checked when a feature is clicked to determine if tracing should be active.\n   */\n  setTrace(trace) {\n    let condition;\n    if (!trace) {\n      condition = never;\n    } else if (trace === true) {\n      condition = always;\n    } else {\n      condition = trace;\n    }\n    this.traceCondition_ = condition;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    super.setMap(map);\n    this.updateState_();\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.originalEvent.preventDefault();\n    }\n    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);\n    let move = event.type === MapBrowserEventType.POINTERMOVE;\n    let pass = true;\n    if (\n      !this.freehand_ &&\n      this.lastDragTime_ &&\n      event.type === MapBrowserEventType.POINTERDRAG\n    ) {\n      const now = Date.now();\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n    if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDRAG &&\n      this.sketchFeature_ !== null\n    ) {\n      this.addToDrawing_(event.coordinate);\n      pass = false;\n    } else if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDOWN\n    ) {\n      pass = false;\n    } else if (move && this.getPointerCount() < 2) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n      if (pass && this.freehand_) {\n        this.handlePointerMove_(event);\n        if (this.shouldHandle_) {\n          // Avoid page scrolling when freehand drawing on mobile\n          event.originalEvent.preventDefault();\n        }\n      } else if (\n        event.originalEvent.pointerType === 'mouse' ||\n        (event.type === MapBrowserEventType.POINTERDRAG &&\n          this.downTimeout_ === undefined)\n      ) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n\n    return super.handleEvent(event) && pass;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event.coordinate);\n      }\n      return true;\n    }\n\n    if (!this.condition_(event)) {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n\n    this.lastDragTime_ = Date.now();\n    this.downTimeout_ = setTimeout(() => {\n      this.handlePointerMove_(\n        new MapBrowserEvent(\n          MapBrowserEventType.POINTERMOVE,\n          event.map,\n          event.originalEvent,\n          false,\n          event.frameState\n        )\n      );\n    }, this.dragVertexDelay_);\n    this.downPx_ = event.pixel;\n    return true;\n  }\n\n  /**\n   * @private\n   */\n  deactivateTrace_() {\n    this.traceState_ = {active: false};\n  }\n\n  /**\n   * Activate or deactivate trace state based on a browser event.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  toggleTraceState_(event) {\n    if (!this.traceSource_ || !this.traceCondition_(event)) {\n      return;\n    }\n\n    if (this.traceState_.active) {\n      this.deactivateTrace_();\n      return;\n    }\n\n    const map = this.getMap();\n    const lowerLeft = map.getCoordinateFromPixel([\n      event.pixel[0] - this.snapTolerance_,\n      event.pixel[1] + this.snapTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      event.pixel[0] + this.snapTolerance_,\n      event.pixel[1] - this.snapTolerance_,\n    ]);\n    const extent = boundingExtent([lowerLeft, upperRight]);\n    const features = this.traceSource_.getFeaturesInExtent(extent);\n    if (features.length === 0) {\n      return;\n    }\n\n    const targets = getTraceTargets(event.coordinate, features);\n    if (targets.length) {\n      this.traceState_ = {\n        active: true,\n        startPx: event.pixel.slice(),\n        targets: targets,\n        targetIndex: -1,\n      };\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} endIndex The new end index of the trace.\n   * @private\n   */\n  addOrRemoveTracedCoordinates_(target, endIndex) {\n    // three cases to handle:\n    //  1. traced in the same direction and points need adding\n    //  2. traced in the same direction and points need removing\n    //  3. traced in a new direction\n    const previouslyForward = target.startIndex <= target.endIndex;\n    const currentlyForward = target.startIndex <= endIndex;\n    if (previouslyForward === currentlyForward) {\n      // same direction\n      if (\n        (previouslyForward && endIndex > target.endIndex) ||\n        (!previouslyForward && endIndex < target.endIndex)\n      ) {\n        // case 1 - add new points\n        this.addTracedCoordinates_(target, target.endIndex, endIndex);\n      } else if (\n        (previouslyForward && endIndex < target.endIndex) ||\n        (!previouslyForward && endIndex > target.endIndex)\n      ) {\n        // case 2 - remove old points\n        this.removeTracedCoordinates_(endIndex, target.endIndex);\n      }\n    } else {\n      // case 3 - remove old points, add new points\n      this.removeTracedCoordinates_(target.startIndex, target.endIndex);\n      this.addTracedCoordinates_(target, target.startIndex, endIndex);\n    }\n  }\n\n  /**\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  removeTracedCoordinates_(fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    let remove = 0;\n    if (fromIndex < toIndex) {\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        end -= 1;\n      }\n      remove = end - start + 1;\n    } else {\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      remove = start - end + 1;\n    }\n\n    if (remove > 0) {\n      this.removeLastPoints_(remove);\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  addTracedCoordinates_(target, fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    const coordinates = [];\n    if (fromIndex < toIndex) {\n      // forward trace\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        // if end is snapped to a vertex, it will be added later\n        end -= 1;\n      }\n      for (let i = start; i <= end; ++i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    } else {\n      // reverse trace\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      for (let i = start; i >= end; --i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    }\n    if (coordinates.length) {\n      this.appendCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * Update the trace.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  updateTrace_(event) {\n    const traceState = this.traceState_;\n    if (!traceState.active) {\n      return;\n    }\n\n    if (traceState.targetIndex === -1) {\n      // check if we are ready to pick a target\n      if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {\n        return;\n      }\n    }\n\n    const updatedTraceTarget = getTraceTargetUpdate(\n      event.coordinate,\n      traceState,\n      this.getMap(),\n      this.snapTolerance_\n    );\n\n    if (traceState.targetIndex !== updatedTraceTarget.index) {\n      // target changed\n      if (traceState.targetIndex !== -1) {\n        // remove points added during previous trace\n        const oldTarget = traceState.targets[traceState.targetIndex];\n        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);\n      }\n      // add points for the new target\n      const newTarget = traceState.targets[updatedTraceTarget.index];\n      this.addTracedCoordinates_(\n        newTarget,\n        newTarget.startIndex,\n        updatedTraceTarget.endIndex\n      );\n    } else {\n      // target stayed the same\n      const target = traceState.targets[traceState.targetIndex];\n      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);\n    }\n\n    // modify the state with updated info\n    traceState.targetIndex = updatedTraceTarget.index;\n    const target = traceState.targets[traceState.targetIndex];\n    target.endIndex = updatedTraceTarget.endIndex;\n\n    // update event coordinate and pixel to match end point of final segment\n    const coordinate = interpolateCoordinate(\n      target.coordinates,\n      target.endIndex\n    );\n    const pixel = this.getMap().getPixelFromCoordinate(coordinate);\n    event.coordinate = coordinate;\n    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(event) {\n    let pass = true;\n\n    if (this.getPointerCount() === 0) {\n      if (this.downTimeout_) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n\n      this.handlePointerMove_(event);\n      const tracing = this.traceState_.active;\n      this.toggleTraceState_(event);\n\n      if (this.shouldHandle_) {\n        const startingToDraw = !this.finishCoordinate_;\n        if (startingToDraw) {\n          this.startDrawing_(event.coordinate);\n        }\n        if (!startingToDraw && this.freehand_) {\n          this.finishDrawing();\n        } else if (\n          !this.freehand_ &&\n          (!startingToDraw || this.mode_ === 'Point')\n        ) {\n          if (this.atFinish_(event.pixel, tracing)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event.coordinate);\n          }\n        }\n        pass = false;\n      } else if (this.freehand_) {\n        this.abortDrawing();\n      }\n    }\n\n    if (!pass && this.stopClick_) {\n      event.preventDefault();\n    }\n    return pass;\n  }\n\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @private\n   */\n  handlePointerMove_(event) {\n    this.pointerType_ = event.originalEvent.pointerType;\n    if (\n      this.downPx_ &&\n      ((!this.freehand_ && this.shouldHandle_) ||\n        (this.freehand_ && !this.shouldHandle_))\n    ) {\n      const downPx = this.downPx_;\n      const clickPx = event.pixel;\n      const dx = downPx[0] - clickPx[0];\n      const dy = downPx[1] - clickPx[1];\n      const squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_\n        ? squaredDistance > this.squaredClickTolerance_\n        : squaredDistance <= this.squaredClickTolerance_;\n      if (!this.shouldHandle_) {\n        return;\n      }\n    }\n\n    if (!this.finishCoordinate_) {\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\n      return;\n    }\n\n    this.updateTrace_(event);\n    this.modifyDrawing_(event.coordinate);\n  }\n\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n  atFinish_(pixel, tracing) {\n    let at = false;\n    if (this.sketchFeature_) {\n      let potentiallyDone = false;\n      let potentiallyFinishCoordinates = [this.finishCoordinate_];\n      const mode = this.mode_;\n      if (mode === 'Point') {\n        at = true;\n      } else if (mode === 'Circle') {\n        at = this.sketchCoords_.length === 2;\n      } else if (mode === 'LineString') {\n        potentiallyDone =\n          !tracing && this.sketchCoords_.length > this.minPoints_;\n      } else if (mode === 'Polygon') {\n        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [\n          sketchCoords[0][0],\n          sketchCoords[0][sketchCoords[0].length - 2],\n        ];\n        if (tracing) {\n          potentiallyFinishCoordinates = [sketchCoords[0][0]];\n        } else {\n          potentiallyFinishCoordinates = [\n            sketchCoords[0][0],\n            sketchCoords[0][sketchCoords[0].length - 2],\n          ];\n        }\n      }\n      if (potentiallyDone) {\n        const map = this.getMap();\n        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          const finishCoordinate = potentiallyFinishCoordinates[i];\n          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          const dx = pixel[0] - finishPixel[0];\n          const dy = pixel[1] - finishPixel[1];\n          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at;\n  }\n\n  /**\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n   * @private\n   */\n  createOrUpdateSketchPoint_(coordinates) {\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new Feature(new Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @private\n   */\n  createOrUpdateCustomSketchLine_(geometry) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new Feature();\n    }\n    const ring = geometry.getLinearRing(0);\n    let sketchLineGeom = this.sketchLine_.getGeometry();\n    if (!sketchLineGeom) {\n      sketchLineGeom = new LineString(\n        ring.getFlatCoordinates(),\n        ring.getLayout()\n      );\n      this.sketchLine_.setGeometry(sketchLineGeom);\n    } else {\n      sketchLineGeom.setFlatCoordinates(\n        ring.getLayout(),\n        ring.getFlatCoordinates()\n      );\n      sketchLineGeom.changed();\n    }\n  }\n\n  /**\n   * Start the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n   * @private\n   */\n  startDrawing_(start) {\n    const projection = this.getMap().getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    while (start.length < stride) {\n      start.push(0);\n    }\n    this.finishCoordinate_ = start;\n    if (this.mode_ === 'Point') {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === 'Polygon') {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n    }\n    const geometry = this.geometryFunction_(\n      this.sketchCoords_,\n      undefined,\n      projection\n    );\n    this.sketchFeature_ = new Feature();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)\n    );\n  }\n\n  /**\n   * Modify the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @private\n   */\n  modifyDrawing_(coordinate) {\n    const map = this.getMap();\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = map.getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    let coordinates, last;\n    while (coordinate.length < stride) {\n      coordinate.push(0);\n    }\n    if (this.mode_ === 'Point') {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      last = coordinates[coordinates.length - 1];\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(\n      /** @type {!LineCoordType} */ (this.sketchCoords_),\n      geometry,\n      projection\n    );\n    if (this.sketchPoint_) {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {\n      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n    } else if (this.sketchLineCoords_) {\n      const sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {!PointCoordType} coordinate Coordinate\n   * @private\n   */\n  addToDrawing_(coordinate) {\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    let done;\n    let coordinates;\n    const mode = this.mode_;\n    if (mode === 'LineString' || mode === 'Circle') {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (mode === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n    this.createOrUpdateSketchPoint_(coordinate.slice());\n    this.updateSketchFeatures_();\n    if (done) {\n      this.finishDrawing();\n    }\n  }\n\n  /**\n   * @param {number} n The number of points to remove.\n   */\n  removeLastPoints_(n) {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    const mode = this.mode_;\n    for (let i = 0; i < n; ++i) {\n      let coordinates;\n      if (mode === 'LineString' || mode === 'Circle') {\n        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n        coordinates.splice(-2, 1);\n        if (coordinates.length >= 2) {\n          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n          const finishCoordinate = this.finishCoordinate_.slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        this.geometryFunction_(coordinates, geometry, projection);\n        if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n          this.createOrUpdateCustomSketchLine_(\n            /** @type {Polygon} */ (geometry)\n          );\n        }\n      } else if (mode === 'Polygon') {\n        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n        coordinates.splice(-2, 1);\n        const sketchLineGeom = this.sketchLine_.getGeometry();\n        if (coordinates.length >= 2) {\n          const finishCoordinate = coordinates[coordinates.length - 2].slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        sketchLineGeom.setCoordinates(coordinates);\n        this.geometryFunction_(this.sketchCoords_, geometry, projection);\n      }\n\n      if (coordinates.length === 1) {\n        this.abortDrawing();\n        break;\n      }\n    }\n\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Remove last point of the feature currently being drawn. Does not do anything when\n   * drawing POINT or MULTI_POINT geometries.\n   * @api\n   */\n  removeLastPoint() {\n    this.removeLastPoints_(1);\n  }\n\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @api\n   */\n  finishDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (!sketchFeature) {\n      return;\n    }\n    let coordinates = this.sketchCoords_;\n    const geometry = sketchFeature.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    if (this.mode_ === 'LineString') {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (this.mode_ === 'Polygon') {\n      // remove the redundant last point in ring\n      /** @type {PolyCoordType} */ (coordinates)[0].pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n      coordinates = geometry.getCoordinates();\n    }\n\n    // cast multi-part geometries\n    if (this.type_ === 'MultiPoint') {\n      sketchFeature.setGeometry(\n        new MultiPoint([/** @type {PointCoordType} */ (coordinates)])\n      );\n    } else if (this.type_ === 'MultiLineString') {\n      sketchFeature.setGeometry(\n        new MultiLineString([/** @type {LineCoordType} */ (coordinates)])\n      );\n    } else if (this.type_ === 'MultiPolygon') {\n      sketchFeature.setGeometry(\n        new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)])\n      );\n    }\n\n    // First dispatch event to allow full set up of feature\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n\n    // Then insert feature\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n   * @private\n   */\n  abortDrawing_() {\n    this.finishCoordinate_ = null;\n    const sketchFeature = this.sketchFeature_;\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n    this.deactivateTrace_();\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @api\n   */\n  abortDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (sketchFeature) {\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n    }\n  }\n\n  /**\n   * Append coordinates to the end of the geometry that is currently being drawn.\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\n   * either be appended to the current LineString or the outer ring of the current\n   * Polygon. If no geometry is being drawn, a new one will be created.\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n   * the coordinate array.\n   * @api\n   */\n  appendCoordinates(coordinates) {\n    const mode = this.mode_;\n    const newDrawing = !this.sketchFeature_;\n    if (newDrawing) {\n      this.startDrawing_(coordinates[0]);\n    }\n    /** @type {LineCoordType} */\n    let sketchCoords;\n    if (mode === 'LineString' || mode === 'Circle') {\n      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n    } else if (mode === 'Polygon') {\n      sketchCoords =\n        this.sketchCoords_ && this.sketchCoords_.length\n          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n          : [];\n    } else {\n      return;\n    }\n\n    if (newDrawing) {\n      sketchCoords.shift();\n    }\n\n    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n    sketchCoords.pop();\n\n    // Append coordinate list\n    for (let i = 0; i < coordinates.length; i++) {\n      this.addToDrawing_(coordinates[i]);\n    }\n\n    const ending = coordinates[coordinates.length - 1];\n    // Duplicate last coordinate for sketch drawing (cursor position)\n    this.addToDrawing_(ending);\n    this.modifyDrawing_(ending);\n  }\n\n  /**\n   * Initiate draw mode by starting from an existing geometry which will\n   * receive new additional points. This only works on features with\n   * `LineString` geometries, where the interaction will extend lines by adding\n   * points to the end of the coordinates array.\n   * This will change the original feature, instead of drawing a copy.\n   *\n   * The function will dispatch a `drawstart` event.\n   *\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n  extend(feature) {\n    const geometry = feature.getGeometry();\n    const lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    const last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.sketchPoint_ = new Feature(new Point(last));\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)\n    );\n  }\n\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n  updateSketchFeatures_() {\n    const sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    const overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  }\n\n  /**\n   * @private\n   */\n  updateState_() {\n    const map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing();\n    }\n    this.overlay_.setMap(active ? map : null);\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(sides, angle) {\n  return function (coordinates, geometry, projection) {\n    const center = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[0],\n      projection\n    );\n    const end = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],\n      projection\n    );\n    const radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    geometry = geometry || fromCircle(new Circle(center), sides);\n\n    let internalAngle = angle;\n    if (!angle && angle !== 0) {\n      const x = end[0] - center[0];\n      const y = end[1] - center[1];\n      internalAngle = Math.atan2(y, x);\n    }\n    makeRegular(\n      /** @type {Polygon} */ (geometry),\n      center,\n      radius,\n      internalAngle\n    );\n\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n  return function (coordinates, geometry, projection) {\n    const extent = boundingExtent(\n      /** @type {LineCoordType} */ ([\n        coordinates[0],\n        coordinates[coordinates.length - 1],\n      ]).map(function (coordinate) {\n        return fromUserCoordinate(coordinate, projection);\n      })\n    );\n    const boxCoordinates = [\n      [\n        getBottomLeft(extent),\n        getBottomRight(extent),\n        getTopRight(extent),\n        getTopLeft(extent),\n        getBottomLeft(extent),\n      ],\n    ];\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new Polygon(boxCoordinates);\n    }\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      return 'Point';\n    case 'LineString':\n    case 'MultiLineString':\n      return 'LineString';\n    case 'Polygon':\n    case 'MultiPolygon':\n      return 'Polygon';\n    case 'Circle':\n      return 'Circle';\n    default:\n      throw new Error('Invalid type: ' + type);\n  }\n}\n\nexport default Draw;\n"],"names":["Circle","SimpleGeometry","constructor","center","radius","layout","super","this","setFlatCoordinates","setCenterAndRadius","clone","circle","flatCoordinates","slice","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","dx","dy","squaredDistance","i","stride","delta","getRadius","Math","sqrt","length","containsXY","getRadiusSquared_","getCenter","computeExtent","extent","createOrUpdate","getType","intersectsExtent","circleExtent","getExtent","intersects","forEachCorner","intersectsCoordinate","bind","setCenter","changed","setLayout","offset","deflateCoordinate","ii","getCoordinates","setCoordinates","coordinates","setRadius","rotate","angle","anchor","getStride","prototype","transform","DrawEventType","DrawEvent","Event","type","feature","getSquaredDistance","a","b","getCoordinate","index","count","getCumulativeSquaredDistance","startIndex","endIndex","lowIndex","highIndex","lowWholeIndex","ceil","highWholeIndex","floor","interpolateCoordinate","sd","appendGeometryTraceTargets","coordinate","geometry","targets","LineString","appendTraceTarget","MultiLineString","Polygon","MultiPolygon","polys","j","jj","GeometryCollection","geometries","getGeometries","sharedUpdateInfo","NaN","ring","rel","getPointSegmentRelationship","along","push","sharedRel","start","end","x1","y1","px","py","clamp","toFixed","x0","y0","Draw","PointerInteraction","options","pointerOptions","stopDown","FALSE","on","once","un","shouldHandle_","downPx_","downTimeout_","lastDragTime_","pointerType_","freehand_","source_","source","features_","features","snapTolerance_","snapTolerance","type_","mode_","Error","getMode","stopClick_","stopClick","minPoints_","minPoints","maxPoints_","maxPoints","Infinity","finishCondition_","finishCondition","TRUE","geometryLayout_","geometryLayout","geometryFunction","mode","projection","fromUserCoordinate","squaredLength","squaredCoordinateDistance","Constructor","Point","concat","geometryFunction_","dragVertexDelay_","dragVertexDelay","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","squaredClickTolerance_","clickTolerance","overlay_","VectorLayer","VectorSource","useSpatialIndex","wrapX","style","getDefaultStyleFunction","updateWhileInteracting","geometryName_","geometryName","condition_","condition","noModifierKeys","freehandCondition_","freehand","always","freehandCondition","shiftKeyOnly","traceCondition_","setTrace","trace","traceState_","active","traceSource_","traceSource","addChangeListener","InteractionProperty","ACTIVE","updateState_","never","setMap","map","getOverlay","handleEvent","event","originalEvent","EventType","CONTEXTMENU","preventDefault","move","MapBrowserEventType","POINTERMOVE","pass","POINTERDRAG","Date","now","pixel","clearTimeout","addToDrawing_","POINTERDOWN","getPointerCount","handlePointerMove_","pointerType","DBLCLICK","handleDownEvent","startDrawing_","setTimeout","MapBrowserEvent","frameState","deactivateTrace_","toggleTraceState_","getMap","lowerLeft","getCoordinateFromPixel","upperRight","boundingExtent","getFeaturesInExtent","getGeometry","getTraceTargets","startPx","targetIndex","addOrRemoveTracedCoordinates_","target","previouslyForward","addTracedCoordinates_","removeTracedCoordinates_","fromIndex","toIndex","remove","removeLastPoints_","appendCoordinates","updateTrace_","traceState","distance","updatedTraceTarget","closestTargetDistance","newTargetIndex","newEndIndex","minSegmentDistance","coordinateIndex","newTarget","considerBothDirections","newCoordinate","getPixelFromCoordinate","forwardDistance","reverseDistance","getTraceTargetUpdate","oldTarget","round","handleUpEvent","tracing","startingToDraw","finishDrawing","atFinish_","abortDrawing","downPx","clickPx","modifyDrawing_","createOrUpdateSketchPoint_","at","potentiallyDone","potentiallyFinishCoordinates","sketchCoords","finishCoordinate","finishPixel","Feature","updateSketchFeatures_","createOrUpdateCustomSketchLine_","getLinearRing","sketchLineGeom","getLayout","getFlatCoordinates","setGeometry","getView","getProjection","getStrideForLayout","setGeometryName","dispatchEvent","last","done","pop","n","splice","removeLastPoint","sketchFeature","abortDrawing_","MultiPoint","addFeature","getSource","clear","newDrawing","shift","ending","extend","lineString","sketchFeatures","overlaySource","addFeatures","getActive","styles","createEditingStyle","resolution"],"mappings":"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","x_google_ignoreList":[0,1]}